
<!-- saved from url=(0109)https://blackboard.case.edu/bbcswebdav/pid-910692-dt-content-rid-1811484_1/courses/eecs345_hsc21_1/part3.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>EECS 345: Interpreter Project, Part 3</title>
</head>

<body>
<h2>EECS 345: Programming Language Concepts</h2>
<h2>Interpreter Project, Part 3</h2>
<h3>Due Sunday, April 7</h3>

<p><em>For this and all Interpreter Project's, you are strongly encouraged, but not required, to work in a team of two.  
You will be building off of the interpreter you wrote for part 1.  As a result, it is expected that you keep the same teams
that you used for part 2.  If you need to change your team, please speak to the course instructor.</em></p>

<p>In this homework, you will expand on the interpreter of part 2 adding function definitions.
We still assume all variables store integers (for the individuals working solo) and integers and boolean (for those
working in teams).  Likewise, all functions will only return integers (for the individuals working solo) and integers
and boolean (for those working in teams).</p>

<p><em>For teams:</em> You are to implement both the <em>call-by-reference</em> and the <em>call-by-value</em>
parameter passing styles.  Solo programmers will only be tested on call-by-value.</p>

<p>An example program that computes the greatest common divisor of two numbers is as follows:</p>
<pre>var x = 14;
var y = 3 * x - 7;
gcd(a,b) {
  if (a &lt; b) {
    var temp = a;
    a = b;
    b = temp;
  }
  var r = a % b;
  while (r != 0) {
    a = b;
    b = r;
    r = a % b;
  }
  return b;
}
main () {
  return gcd(x,y);
}
</pre>

<p>Here is another example program that uses recursion:
</p><pre>factorial (x) {
  if (x == 0)
    return 1;
  else
    return x * factorial(x - 1);
}

main () {
  return factorial(6);
}
</pre>

Note that only assignment statements are allowed outside of functions.  Functions do not have to
return a value.  The parser will have the following additional constructs:
<pre>a(x, y) {          =&gt;   (function a (x y) ((return (+ x y)))
  return x + y;
}

main () {          =&gt;   (function main () ((var x 10) (var y 15) (return (funcall gcd x y))))
  var x = 10;
  var y = 15;
  return gcd(x, y);
}
</pre>

The final value returned by your interpreter should be whatever is returned by <tt>main</tt>. <p></p>

<p>We will use a similar style as C++ for call-by-reference:
</p><pre>swap(&amp;x, &amp;y) {     =&gt;  (function swap (&amp; x &amp; y) ((var temp x) (= x y) (= y temp)))
  var temp = x;
  x = y;
  y = temp;
}
</pre><p></p>

<p>Function calls may appear on the right hand side of global variable declaration/initialization statements, but the function
(and any functions that function calls) must be defined before the variable declaration.  Otherwise, functions that are used
inside other functions do not need to be defined before they are used.</p>

<p>For teams, it is an error to use call-by-reference on anything other than a variable.  For example, if the program contains
<tt>swap(x, x + 10)</tt>, you should give an error because <tt>x + 10</tt> is not a variable.</p>

<p>You do not have to stick to strict functional programming style, but you should try to avoid
global variables because they will probably make your life harder.  A new parser is provided
for you, <tt>functionParser.scm</tt>, that will parse code 
containing functions/methods as in the above examples.  To
use the parser, type the code into a file, and call <tt>(parser "<em>filename</em>")</tt> as before.  To call the
parsers from your interpreter code, place the command <tt>(load "<em>parsename</em>")</tt> in the Scheme file.</p>

<p>You should write a function called <tt>interpret</tt> that takes a filename, calls <tt>parser</tt>
with the filename, evaluates the parse tree returned by <tt>parser</tt>, and returns the
proper value returned by <tt>main</tt>.  You are to maintain
an environment for the variables and return an error message if the program attempts to use a variable before it is declared,
attempts to use a variable before it is initialized,  or attempts to use a method that has not been defined.</p>

<p>First, test your functions without global variables,
and then test your functions using global variables.  The tricky part with the functions is that, unlike the other language
constructs we have created, method calls can be a statement (where the return value is ignored), and an expression (where
the return value is used).  You need to make sure both function types work.</p>



</body></html>